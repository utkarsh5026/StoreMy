# Primitives Package

This package defines the fundamental primitive types used throughout the StoreMy database system.

## FileID, TableID, and IndexID

### Design Philosophy

`TableID` and `IndexID` represent the same underlying concept - a unique file identifier generated by hashing a file path. However, they serve different semantic purposes in the system:

- **FileID**: The base type representing any file identifier (hash of file path)
- **TableID**: Identifies heap files storing table data
- **IndexID**: Identifies index files (B-tree, hash indexes)

### Why Separate Types?

Even though they're fundamentally the same, we maintain separate types for:

1. **Type Safety**: Prevents accidentally using an IndexID where a TableID is expected
2. **Semantic Clarity**: Makes code more readable and self-documenting
3. **Future Flexibility**: Allows different behavior or constraints if needed later

### Type Hierarchy

```
FileID (uint64)
  ├── TableID (FileID)
  └── IndexID (FileID)
```

All three types share the same underlying `uint64` representation, but Go's type system keeps them distinct.

### Common Use Cases

#### Creating IDs from file paths

```go
// Using FileID (generic)
path := primitives.Filepath("/data/users.dat")
fileID := path.Hash()

// Using TableID (semantic)
tablePath := primitives.Filepath("/data/users.dat")
tableID := tablePath.HashAsTableID()

// Using IndexID (semantic)
indexPath := primitives.Filepath("/data/indexes/users_id.idx")
indexID := indexPath.HashAsIndexID()
```

#### Converting between types

```go
// FileID to TableID/IndexID
fileID := primitives.FileID(12345)
tableID := primitives.NewTableIDFromFileID(fileID)
indexID := primitives.NewIndexIDFromFileID(fileID)

// TableID to FileID
tableID := primitives.TableID(12345)
fileID := tableID.ToFileID()

// TableID to IndexID (use with caution!)
tableID := primitives.TableID(12345)
indexID := tableID.AsIndexID() // Only when semantically correct

// From uint64
tableID := primitives.NewTableIDFromUint64(12345)
indexID := primitives.NewIndexIDFromUint64(67890)
```

#### Validation and utility methods

```go
// Check validity
if !tableID.IsValid() {
    return errors.New("invalid table ID")
}

// Convert to uint64 for storage/serialization
idValue := tableID.AsUint64()

// String representation for logging
log.Printf("Processing %s", tableID.String()) // "TableID(12345)"
```

### Implementation Details

The hash function uses FNV-1a hashing which provides:
- **Deterministic**: Same path always produces the same ID
- **Fast**: Efficient computation for frequent lookups
- **Collision-resistant**: Different paths (almost) always produce different IDs

### Important Notes

⚠️ **Warning**: The conversion methods `AsTableID()` and `AsIndexID()` bypass type safety. Only use them when you're certain the semantic meaning is correct. These exist for cases where:
- Internal conversions are needed
- A file is being repurposed
- You're working at a low level where the distinction doesn't matter

### Architecture Impact

This design allows the storage layer to work with generic `FileID` types while higher layers maintain semantic distinctions:

```
Application Layer:     TableID, IndexID (semantic types)
        ↓
Storage Layer:         FileID (generic file operations)
        ↓
Filesystem:            uint64 (actual hash value)
```

### Examples in the Codebase

**BaseFile** (storage/page/commons.go):
```go
type BaseFile struct {
    fileID   primitives.FileID   // Generic file identifier
    filePath primitives.Filepath
}

func NewBaseFile(filePath primitives.Filepath) (*BaseFile, error) {
    return &BaseFile{
        fileID:   filePath.Hash(), // Uses FileID
        filePath: filePath,
    }, nil
}
```

**Heap File** (storage/heap/file.go):
```go
// Returns TableID since it's a table file
func (hf *HeapFile) GetID() primitives.TableID {
    return hf.baseFile.GetID().AsTableID() // Semantic conversion
}
```

**Index File** (storage/index/btree/btree_file.go):
```go
// Returns IndexID since it's an index file
func (bf *BTreeFile) GetID() primitives.IndexID {
    return bf.baseFile.GetID().AsIndexID() // Semantic conversion
}
```

## Filepath Type

See [filepath.go](filepath.go) for comprehensive documentation on the `Filepath` type and its utility methods.

Key features:
- Type-safe path manipulation
- File existence checking
- Directory creation
- File removal
- Hash generation for file IDs

## Other Primitive Types

- **LSN**: Log Sequence Number for WAL
- **PageNumber**: Page number within a file
- **SlotID**: Slot number within a page
- **ColumnID**: Column identifier within a table
- **HashCode**: Generic hash value
- **LockID**: Lock identifier
- **Timestamp**: Logical/physical timestamp
- **CheckpointID**: Checkpoint identifier
- **Offset**: Byte offset (page, file, log)
- **RowID**: Row identifier

See [types.go](types.go) for complete definitions.
